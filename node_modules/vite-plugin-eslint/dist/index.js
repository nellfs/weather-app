"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => eslintPlugin
});
module.exports = __toCommonJS(src_exports);
var import_path = require("path");
var import_eslint = require("eslint");
var import_pluginutils = require("@rollup/pluginutils");

// package.json
var name = "vite-plugin-eslint";

// src/utils.ts
function parseRequest(id) {
  return id.split("?", 2)[0];
}
function pickESLintOptions(options) {
  const {
    include,
    exclude,
    formatter,
    emitWarning,
    emitError,
    failOnWarning,
    failOnError,
    throwOnError,
    throwOnWarning,
    ...eslintOptions
  } = options;
  return eslintOptions;
}

// src/index.ts
function eslintPlugin(rawOptions = {}) {
  let eslint;
  let filter;
  let formatter;
  let options;
  const pathCache = /* @__PURE__ */ new Set();
  return {
    name,
    async configResolved(config) {
      options = Object.assign({
        include: /\.(jsx?|tsx?|vue|svelte)$/,
        exclude: /node_modules/,
        cacheLocation: (0, import_path.resolve)(config.cacheDir, ".eslintcache"),
        formatter: "stylish",
        emitWarning: true,
        emitError: true,
        failOnWarning: false,
        failOnError: true,
        throwOnWarning: false,
        throwOnError: false
      }, rawOptions);
      const eslintOptions = pickESLintOptions(options);
      filter = (0, import_pluginutils.createFilter)(options.include, options.exclude);
      eslint = new import_eslint.ESLint(eslintOptions);
      switch (typeof options.formatter) {
        case "string":
          formatter = (await eslint.loadFormatter(options.formatter)).format;
          break;
        case "function":
          formatter = options.formatter;
        default:
          break;
      }
    },
    async transform(_, id) {
      const filePath = parseRequest(id);
      if (!filter(filePath) || await eslint.isPathIgnored(filePath)) {
        return null;
      }
      if (options.cache) {
        pathCache.add(filePath);
      }
      const report = await eslint.lintFiles(options.cache ? Array.from(pathCache) : filePath);
      const hasWarning = report.some((item) => item.warningCount > 0);
      const hasError = report.some((item) => item.errorCount > 0);
      const result = formatter(report);
      if (options.fix && report) {
        import_eslint.ESLint.outputFixes(report);
      }
      if (hasWarning && (options.emitWarning || options.throwOnWarning)) {
        const warning = typeof result === "string" ? result : await result;
        if (options.failOnWarning) {
          this.error(warning);
        } else {
          this.warn(warning);
        }
      }
      if (hasError && (options.emitError || options.throwOnError)) {
        const error = typeof result === "string" ? result : await result;
        if (options.failOnError) {
          this.error(error);
        } else {
          console.log(error);
        }
      }
      return null;
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
